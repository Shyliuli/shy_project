shy_language的整体思路借鉴了x86汇编语言，它由多条命令组成。每个命令的格式如下所示：`add 0x1234 1234`。
其中，第一个部分是内建的系统调用，表示需要执行的操作。第二个和第三个部分是命令的参数。
参数可以分为两种类型：立即数和地址。立即数是具体的数值，而地址表示需要操作的内存地址。

你也可以使用[ox]表示某个地址所指向的内容，根据语法会自动判断此内容为参数还是立即数。

你还可以使用[[ox]]等方式多次套娃（笑）。
下面所有内容中用ox表示地址，num表示立即数，若有多个同类参数，则表示为ox1，ox2或num1，num2

程序在运行前需要通过编译器将指令转换为对应的二进制形式，并将其写入内存。在下面的所有内容中，我们用ox表示一个内存地址，用num表示一个立即数。如果有多个相同类型的参数，则用ox1、ox2或num1、num2来表示它们。

我们还会用到ax，bx....jx共8个寄存器，其中ax-ex为通用寄存器，fx专门用于存储cpe和equ的结果，gx被赋非0值时退出程序，hx用于保存and or xor的结果，ix-px也是通用寄存器（为什么选fx，gx，hx作为特殊寄存器？一方面作者曾设计过8寄存器版本发现不够用，但是特殊寄存器就保留了；另一方面感谢数学这辈子也忘不了fx，gx了（笑））

<span id="add">以下是一个示例：</span>

对于指令 `add [0x1234] 1234`，编译器将其转换为二进制形式 `10 12 34 01 04 D2 00`。

其中，`10` 表示 `add` 操作码对应的地址；`12 34` 表示参数一，即内存地址 `0x1234`；`01` 表示参数一是一个指针，需要通过该地址读取其指向的内容；`04 D2` 表示参数二，即立即数 `1234` 的十六进制表示；`00` 表示参数二为一个值，直接使用该值。

在执行指令之前，内存中的状态如下表所示：


| 地址 | 0x1234 | 0x5201 |
| ------ | -------- | -------- |
| 内容 | 0x5201 | 0x0000 |

在执行指令后，内存中的状态如下表所示：


| 地址 | 0x1234 | 0x5201 |
| ------ | -------- | -------- |
| 内容 | 0x5201 | 0x04D2 |

下面是所有内建命令:


| 命令         | 地址 | 命令            | 地址 |
| -------------- | ------ | ----------------- | ------ |
| [add](#add1) | 0x10 | [mov](#mov)     | 0x18 |
| [sub](#sub)  | 0x11 | [reset](#reset) | 0x19 |
| [sl](#sl)    | 0x12 | [cpe](#cpe)     | 0x1A |
| [rl](#rl)    | 0x13 | [in](#in)       | 0x1B |
| [and](#and)  | 0x14 | [out](#out)     | 0x1C |
| [or](#oe)    | 0x15 | [jmp](#jmp)     | 0x1D |
| [xor](#xor)  | 0x16 | [equ](#equ)     | 0x1E |
| [nor](#nor)  | 0x17 | [set](#set)     | 0x1F |

#### 1.add

<p id=add1>语法:</p>

`add ox num`

将`ox`指向的内容加上`num`

例子:同[示例](#add)

#### 2.sub

<p id=sub>语法:</p>

`sub ox num`

将`ox`指向的内容减去`num`
例子：运行前
0x0001：0x0099
运行`sub 0x01 0x09`
0x0001：0x0090

#### 3.sl

<p id=sl>语法:</p>

`sl ox num`

将`ox`指向的内容左移`num`位
例子：运行前
0x0001:0x0520
运行`sl 0x01 0x01`
0x0001:0x0A40

#### 4.rl

<p id=rl>语法：</p>

`rl ox num`

将`ox`指向的内容右移`num`位
例子：运行前
0x0001:0x0A40
运行`rl 0x01 0x01`
0x0001:0x0520

#### 5.and

<p id=and>语法：</p>

`and num1 num2`

将`num1`和`num2`进行AND操作，结果保存在寄存器`hx`中。
例子：运行前
0x0001:0x00FF
运行`and 0x01 0xFF`
0x0001:0x0000

#### 6.or

<p id=or>语法：</p>

`or num1 num2`

将`num1`和`num2`进行OR操作，结果保存在寄存器`hx`中。

例子：运行前
0x0001:0xFFFF
运行``or 0x01 0xFF`
0x0001:0x00FF

#### 7.xor

<p id=xor>语法：</p>

`xor num1 num2`

将`num1`和`num2`进行XOR操作，结果保存在寄存器`hx`中。
例子：运行前
0x0001:0xFF00
运行`xor 0x01 0xF0F0`
0x0001:0x0FF0

#### 8.nor

<p id=nor>语法：</p>

`nor num `

将`num`进行NOR操作，结果保存在寄存器`hx`中。
例子：运行前
0x0001:0x0FFF
运行`nor 0x01 `
0x0001:0xF000

#### 9.mov

<p id=mov>语法：</p>

`mov ox1 ox2`

将`ox1`指向的内容赋值给`ox2`；并将 `ox1`清0。
例子：运行前
0x0001:0x0A40
0x0002:0x0012
运行`mov 0x0001 0x0002`
0x0001:0x0000
0x0002:0x0A40

#### 10.reset

<p id=reset>语法：</p>

`reset ox`
将`ox`指向的内容清0。
例子：运行前
0x0001:0x0A40
运行`reset 0x0001`
0x0001:0x0000

#### 11.cpe

<p id=cpe>语法：</p>

`cpe num1 num2`

比较num1和num2，若num1>=num2，赋值fx为0x01，反之则赋值fx为0x00。
例子：运行前
0x0001:0xFFFF
0x0002:0x0000
fx=0xFF
运行`cpe [0x0002] [0x0001]`
0x0001:0xFFFF
0x0002:0x0000
fx=0x00

#### 12.in

<p id=in>语法：</p>

`in ox `
输入字节，保存在寄存器`ox`中。
例子：运行前
0x0001:0x12
运行`in 0x0001`
输入0x1234
0x0001:0x1234

#### 13.out

<p id=out>语法：</p>

`out `
输出`ax`指向的字节
例子：运行前
0x0001:0x34
运行`out `
输出0x34

#### 14.jmp

<p id=jmp>语法：</p>

`jmp ox/label`
若fx=0x0001跳转至`ox`指定的位置。
反之不跳转
可以用`.ThisIsALabel`
创建一个label
label等效于label下一条指令第一个字节的地址
因为每一条指令都会被编译为7个字节
所以设下一个命令为第n条命令
label=7n+0x20（为什么要加0x20见[[地址表](https://github.com/Shyliuli/shy_project/blob/shy_hardware/README.md)]
例子：

```in ax
set bx 0x10//set就是赋值语句，见16.set
cpe [ax] [bx]//若[ax]比[bx]小，fx=0x00，反之则为0x01
jmp 0x2A//只有fx为0x00时跳转
out 0x01
set  gx 0x01//gx不为0x00时程序退出，这条命令地址为0x2A
```

这段代码中，输入内容小于0x10则输出0x01，反之则直接跳转到`set gx 0x01`语句直接退出。

#### 15.equ

<p id=equ>语法：</p>

`equ num1 num2`

若num1 = num2，fx=0x01，反之fx=0x00
例子：
运行前fx=0x01
运行`equ 0x10 0x20`
fx=0x00

#### 16.set

<p id=set>语法：</p>

`set ox num`
将ox赋值为num
例子：
运行前ax=0x01
运行`set ax 0x05`
ax=0x05
