shy_language的整体思路借鉴了x86汇编语言，它由多条命令组成。每个命令的格式如下所示：`add 0x1234 1234`。
其中，第一个部分是内建的系统调用，表示需要执行的操作。第二个和第三个部分是命令的参数。
参数可以分为两种类型：立即数和地址。立即数是具体的数值，而地址表示需要操作的内存地址。

你也可以使用[ox]表示某个地址所指向的内容，根据语法会自动判断此内容为参数还是立即数。

你还可以使用[[ox]]等方式多次套娃（笑）。
下面所有内容中用ox表示地址，num表示立即数，若有多个同类参数，则表示为ox1，ox2或num1，num2

程序运行前需要编译器将命令转为对应地址，然后以二进制形式写入内存。

下面是一个例子
`add [0x1234] 1234`会转为

```
10 12 34 01 04 D2 00
```

10为add的地址，后面的12 34为参数一，01说明参数一是0x1234所指向的内容而非其本身，04D2是1234（十进制）的十六进制表示，最后的00说明参数2就是1234本身。
假设执行这行代码前是这样的：


| 地址 | 0x1234 | 0x5201 |
| ------ | -------- | -------- |
| 内容 | 0x5201 | 0x0000 |

（执行时，[0x1234]会视为0x1234指向的内容也就是0x5201）

执行后


| 地址 | 0x1234 | 0x5201 |
| ------ | -------- | -------- |
| 内容 | 0x5201 | 0x04D2 |

下面是所有内建命令:


| 命令 | 地址 | 命令  | 地址 |
| ------ | ------ | ------- | ------ |
| add  | 0x10 | mov   | 0x18 |
| sub  | 0x11 | reset | 0x19 |
| sl   | 0x12 | cpe   | 0x1A |
| rl   | 0x13 | in    | 0x1B |
| and  | 0x14 | out   | 0x1C |
| or   | 0x15 | jmp   | 0x1D |
| xor  | 0x16 | equ   | 0x1E |
| nor  | 0x17 | set   | 0x1F |

#### 1.add
